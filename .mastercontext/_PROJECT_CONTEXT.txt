Directory structure:
├── LICENSE
├── README.md
├── components.json
├── index.html
├── package.json
├── public/
├── src-tauri/
│   ├── Cargo.toml
│   ├── build.rs
│   ├── capabilities/
│   │   └── default.json
│   ├── gen/
│   ├── icons/
│   │   ├── 128x128.png
│   │   ├── 128x128@2x.png
│   │   ├── 32x32.png
│   │   ├── Square107x107Logo.png
│   │   ├── Square142x142Logo.png
│   │   ├── Square150x150Logo.png
│   │   ├── Square284x284Logo.png
│   │   ├── Square30x30Logo.png
│   │   ├── Square310x310Logo.png
│   │   ├── Square44x44Logo.png
│   │   ├── Square71x71Logo.png
│   │   ├── Square89x89Logo.png
│   │   ├── StoreLogo.png
│   │   ├── icon.icns
│   │   ├── icon.ico
│   │   └── icon.png
│   └── tauri.conf.json
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts


================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2025 NguyenHuynhPhuVinh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
FILE: README.md
================================================
### I. Cải tiến Chất lượng Trải nghiệm (Quality of Life - QoL) - Dễ thực hiện, tác động lớn

Đây là những tính năng nhỏ nhưng sẽ giúp người dùng sử dụng ứng dụng mượt mà và hiệu quả hơn rất nhiều.

1.  **Nút "Sao chép vào Clipboard":**

    - **Vấn đề:** Hiện tại, người dùng phải "Xuất" ra file rồi mở file đó lên để sao chép nội dung.
    - **Giải pháp:** Bên cạnh nút "Xuất", thêm một nút "Sao chép" (Copy to Clipboard). Khi nhấn, ứng dụng sẽ gọi command Rust để tạo context và trả về nội dung, sau đó frontend sẽ trực tiếp đưa nội dung đó vào clipboard của hệ điều hành. Đây là tính năng cực kỳ hữu ích cho luồng làm việc với LLM.

2.  **Tìm kiếm/Lọc trong Cây Thư mục:**

    - **Vấn đề:** Với các dự án lớn, việc tìm một file/thư mục cụ thể trong `FileTreeView` rất mất thời gian.
    - **Giải pháp:** Thêm một ô `Input` phía trên cây thư mục. Khi người dùng gõ, cây thư mục sẽ tự động lọc và chỉ hiển thị các file/thư mục khớp với tên tìm kiếm (và các thư mục cha của chúng).

3.  **Thông báo (Toast Notifications):**

    - **Vấn đề:** Các hành động như "Quét lại", "Lưu nhóm", "Xuất file" hoàn tất mà không có phản hồi trực quan rõ ràng (chỉ có `alert` hoặc `console.log`).
    - **Giải pháp:** Tích hợp một thư viện thông báo gọn nhẹ (ví dụ: `Sonner` cho React). Hiển thị các thông báo ngắn gọn ở góc màn hình cho các sự kiện như: "Quét lại dự án hoàn tất!", "Lưu nhóm thành công!", "Đã sao chép vào clipboard", "Bắt đầu đồng bộ tự động...".

4.  **Luồng Tạo Nhóm Mượt Hơn:**
    - **Vấn đề:** Sau khi tạo một nhóm mới, người dùng vẫn ở màn hình Dashboard và phải tự nhấn vào "Quản lý nội dung".
    - **Giải pháp:** Sau khi người dùng tạo xong một nhóm mới, tự động chuyển họ đến màn hình `GroupEditorScene` để họ có thể chọn nội dung cho nhóm đó ngay lập tức.

---

### II. Nâng Cấp Tính Năng Cốt Lõi - Tăng cường sức mạnh cho ứng dụng

Đây là những tính năng mở rộng trực tiếp khả năng quản lý ngữ cảnh của ứng dụng.

1.  **Ngân sách Token (Token Budgeting) cho Mỗi Nhóm:**

    - **Vấn đề:** Người dùng không biết ngữ cảnh của họ có vượt quá giới hạn token của LLM hay không cho đến khi xuất ra.
    - **Giải pháp:**
      - Trong dialog tạo/sửa nhóm, thêm một trường để người dùng nhập "Giới hạn Token" (ví dụ: 8000).
      - Trong `GroupManager`, hiển thị một thanh tiến trình hoặc một dòng chữ màu (`12500 / 8000 tokens`) để cảnh báo nếu nhóm vượt quá ngân sách.
      - Khi xuất, nếu vượt quá, có thể đưa ra cảnh báo.

2.  **Tùy chỉnh các Mẫu Loại trừ (Custom Ignore Patterns):**

    - **Vấn đề:** Ứng dụng hiện chỉ dựa vào `.gitignore`. Đôi khi người dùng muốn loại trừ thêm các file/thư mục (ví dụ `*.log`, `dist/`, `__pycache__/`) mà không muốn sửa file `.gitignore` chung của dự án.
    - **Giải pháp:** Trong `SettingsDialog`, thêm một vùng `Textarea` cho phép người dùng nhập các mẫu glob để loại trừ bổ sung. Các mẫu này sẽ được lưu vào file `data.json` và được Rust sử dụng khi quét.

3.  **Hồ sơ Ngữ cảnh (Context Profiles / Workspaces):**
    - **Vấn đề:** Một dự án có thể cần nhiều bộ ngữ cảnh khác nhau cho các tác vụ khác nhau (ví dụ: một bộ cho "Sửa lỗi UI", một bộ khác cho "Tối ưu hóa Database"). Hiện tại tất cả các nhóm đều nằm chung.
    - **Giải pháp:** Cho phép người dùng tạo các "Hồ sơ". Mỗi hồ sơ là một tập hợp các nhóm riêng biệt. Giao diện sẽ có một Dropdown menu để chuyển đổi giữa các hồ sơ như "Mặc định", "Frontend Tasks", "Backend Refactor". Về mặt kỹ thuật, bạn có thể lưu thành các file khác nhau trong thư mục `.mastercontext` (ví dụ: `data_default.json`, `data_frontend.json`).

---

### III. Các Tính Năng Cao Cấp & Đột Phá - "Game Changer"

Đây là những ý tưởng lớn, có thể biến ứng dụng của bạn từ một công cụ hữu ích thành một trợ thủ không thể thiếu.

1.  **Trực quan hóa Đồ thị Phụ thuộc (Dependency Graph Visualization):**

    - **Vấn đề:** Tính năng "liên kết chéo" rất mạnh nhưng nó là một hộp đen. Người dùng không thấy được mối quan hệ giữa các file.
    - **Giải pháp:** Tận dụng dữ liệu `links` đã có trong `file_metadata_cache` để vẽ một đồ thị phụ thuộc.
      - Tạo một tab/màn hình mới.
      - Sử dụng một thư viện như `react-flow` để hiển thị các file dưới dạng các node và các đường import/export dưới dạng các cạnh nối.
      - Người dùng có thể tương tác trực tiếp trên đồ thị: nhấp vào một node để thêm nó và tất cả các phụ thuộc của nó vào một nhóm đang chọn.
      - Đây sẽ là một tính năng cực kỳ "ăn tiền", giúp người dùng hiểu sâu hơn về cấu trúc dự án.

2.  **Lựa chọn ở Cấp độ Hàm/Biểu tượng (Symbol-Level Selection):**

    - **Vấn đề:** Đôi khi người dùng chỉ cần một vài hàm từ một file rất lớn, nhưng họ buộc phải chọn cả file, gây lãng phí token.
    - **Giải pháp:** Đây là tính năng phức tạp nhất nhưng cũng mạnh mẽ nhất.
      - Sử dụng một thư viện phân tích mã nguồn (parser) như `Tree-sitter` ở phía Rust.
      - Khi quét, Rust không chỉ đọc file mà còn phân tích cấu trúc của nó để nhận diện các hàm, class, component...
      - Trong `FileTreeView` ở frontend, cho phép người dùng "mở rộng" một file để xem danh sách các biểu tượng bên trong nó.
      - Người dùng có thể chọn từng hàm/class riêng lẻ để đưa vào ngữ cảnh.
      - Khi xuất, Rust sẽ trích xuất chính xác mã nguồn của các biểu tượng đã chọn.

3.  **Mẫu Nhóm Thông minh (Smart Group Templates):**
    - **Vấn đề:** Người dùng thường lặp đi lặp lại việc tạo các nhóm có cấu trúc tương tự (ví dụ: một nhóm cho component React luôn bao gồm file `.tsx`, file `.css`, và file test `.spec.ts`).
    - **Giải pháp:**
      - Cho phép người dùng tạo "Mẫu". Ví dụ, một mẫu tên "React Component".
      - Mẫu này định nghĩa các quy tắc dựa trên tên file, ví dụ: "Nếu tôi chọn `{name}.tsx`, hãy tự động chọn cả `{name}.module.css` và `{name}.test.tsx`".
      - Khi người dùng kéo thả hoặc chọn file, ứng dụng sẽ kiểm tra xem có khớp với mẫu nào không và đề xuất thêm các file liên quan.


================================================
FILE: components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/App.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}


================================================
FILE: index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tauri + React + Typescript</title>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


================================================
FILE: package.json
================================================
{
  "name": "master-context",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "tauri": "tauri"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.2.2",
    "@radix-ui/react-alert-dialog": "^1.1.15",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@tailwindcss/vite": "^4.1.13",
    "@tauri-apps/api": "^2",
    "@tauri-apps/plugin-clipboard-manager": "^2.3.0",
    "@tauri-apps/plugin-dialog": "^2.4.0",
    "@tauri-apps/plugin-fs": "^2.4.2",
    "@tauri-apps/plugin-opener": "^2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.544.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-hook-form": "^7.63.0",
    "react-icons": "^5.5.0",
    "react-resizable-panels": "^3.0.6",
    "sonner": "2.0.7",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^4.1.13",
    "zod": "^4.1.11",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@tauri-apps/cli": "^2",
    "@types/node": "^24.5.2",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@vitejs/plugin-react": "5.0.3",
    "tw-animate-css": "^1.3.8",
    "typescript": "5.9.2",
    "vite": "7.1.7"
  }
}


================================================
FILE: src-tauri/Cargo.toml
================================================
[package]
name = "master-context"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
# The `_lib` suffix may seem redundant but it is necessary
# to make the lib name unique and wouldn't conflict with the bin name.
# This seems to be only an issue on Windows, see https://github.com/rust-lang/cargo/issues/8519
name = "master_context_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tauri-plugin-dialog = "2"
ignore = "0.4"
tauri-plugin-fs = "2"
tiktoken-rs = "0.7.0"
regex = "1"
lazy_static = "1.5.0"
path-clean = "1.0"
sha2 = "0.10"
tauri-plugin-clipboard-manager = "2"



================================================
FILE: src-tauri/build.rs
================================================
fn main() {
    tauri_build::build()
}


================================================
FILE: src-tauri/capabilities/default.json
================================================
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "opener:default",
    "dialog:default",
    "fs:write-all",
    "clipboard-manager:allow-write-text"
  ]
}


================================================
FILE: src-tauri/tauri.conf.json
================================================
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "master-context",
  "version": "0.1.0",
  "identifier": "com.tomisakae.master-context",
  "build": {
    "beforeDevCommand": "npm run dev",
    "devUrl": "http://localhost:1420",
    "beforeBuildCommand": "npm run build",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "title": "Master Context",
        "width": 1280,
        "height": 720
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ]
  }
}


================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}


================================================
FILE: tsconfig.node.json
================================================
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}


================================================
FILE: vite.config.ts
================================================
import { defineConfig } from "vite";
import path from "path";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";

const host = process.env.TAURI_DEV_HOST;

// https://vite.dev/config/
export default defineConfig(async () => ({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },

  // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
  //
  // 1. prevent Vite from obscuring rust errors
  clearScreen: false,
  // 2. tauri expects a fixed port, fail if that port is not available
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host
      ? {
          protocol: "ws",
          host,
          port: 1421,
        }
      : undefined,
    watch: {
      // 3. tell Vite to ignore watching `src-tauri`
      ignored: ["**/src-tauri/**"],
    },
  },
}));


