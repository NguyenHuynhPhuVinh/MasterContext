Directory structure:
├── LICENSE
├── README.md
├── components.json
├── index.html
├── package.json
├── public/
├── src/
│   ├── App.css
│   ├── App.tsx
│   ├── assets/
│   ├── components/
│   │   ├── FileTreeView.tsx
│   │   ├── GroupManager.tsx
│   │   ├── ProjectStats.tsx
│   │   ├── SettingsDialog.tsx
│   │   ├── ThemeToggle.tsx
│   │   └── ui/
│   │       ├── alert-dialog.tsx
│   │       ├── button.tsx
│   │       ├── card.tsx
│   │       ├── dialog.tsx
│   │       ├── dropdown-menu.tsx
│   │       ├── form.tsx
│   │       ├── input.tsx
│   │       ├── label.tsx
│   │       ├── resizable.tsx
│   │       ├── scroll-area.tsx
│   │       ├── switch.tsx
│   │       ├── textarea.tsx
│   │       └── tooltip.tsx
│   ├── hooks/
│   │   └── useDashboard.ts
│   ├── lib/
│   │   ├── treeUtils.ts
│   │   └── utils.ts
│   ├── main.tsx
│   ├── scenes/
│   │   ├── DashboardScene.tsx
│   │   ├── GroupEditorScene.tsx
│   │   ├── ScanningScene.tsx
│   │   └── WelcomeScene.tsx
│   ├── store/
│   │   ├── appStore.ts
│   │   └── types.ts
│   └── vite-env.d.ts
├── src-tauri/
│   ├── Cargo.toml
│   ├── build.rs
│   ├── capabilities/
│   │   └── default.json
│   ├── gen/
│   ├── icons/
│   │   ├── 128x128.png
│   │   ├── 128x128@2x.png
│   │   ├── 32x32.png
│   │   ├── Square107x107Logo.png
│   │   ├── Square142x142Logo.png
│   │   ├── Square150x150Logo.png
│   │   ├── Square284x284Logo.png
│   │   ├── Square30x30Logo.png
│   │   ├── Square310x310Logo.png
│   │   ├── Square44x44Logo.png
│   │   ├── Square71x71Logo.png
│   │   ├── Square89x89Logo.png
│   │   ├── StoreLogo.png
│   │   ├── icon.icns
│   │   ├── icon.ico
│   │   └── icon.png
│   ├── src/
│   │   ├── commands.rs
│   │   ├── context_generator.rs
│   │   ├── file_cache.rs
│   │   ├── lib.rs
│   │   ├── main.rs
│   │   ├── models.rs
│   │   └── project_scanner.rs
│   └── tauri.conf.json
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts


================================================
FILE: src-tauri/Cargo.toml
================================================
[package]
name = "master-context"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
# The `_lib` suffix may seem redundant but it is necessary
# to make the lib name unique and wouldn't conflict with the bin name.
# This seems to be only an issue on Windows, see https://github.com/rust-lang/cargo/issues/8519
name = "master_context_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tauri-plugin-dialog = "2"
ignore = "0.4"
tauri-plugin-fs = "2"
tiktoken-rs = "0.7.0"
regex = "1"
lazy_static = "1.5.0"
path-clean = "1.0"
sha2 = "0.10"



================================================
FILE: src-tauri/build.rs
================================================
fn main() {
    tauri_build::build()
}


================================================
FILE: src-tauri/capabilities/default.json
================================================
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "opener:default",
    "dialog:default",
    "fs:write-all"
  ]
}


================================================
FILE: src-tauri/src/commands.rs
================================================
// src-tauri/src/commands.rs
use crate::{models, file_cache, project_scanner, context_generator};
use std::fs;
use tauri::{command, Window, Emitter}; // Bỏ AppHandle khỏi use list vì không cần nữa
use std::path::{Path, PathBuf};

#[command]
pub fn open_project(window: Window, path: String) {
    std::thread::spawn(move || {
        // --- LOGIC MỚI, KHÔNG CÒN VÒNG LẶP ---

        // 1. Tải dữ liệu cũ để so sánh hash sau này
        let old_data_result = file_cache::load_project_data(&path);
        let old_hash = old_data_result.as_ref().ok().and_then(|d| d.data_hash.clone());

        // 2. Thực hiện quét (hàm này giờ chỉ trả về dữ liệu, không ghi file)
        match project_scanner::perform_smart_scan_and_rebuild(&path) {
            Ok(new_data) => {
                // 3. Lưu dữ liệu mới vào cache
                if let Err(e) = file_cache::save_project_data(&path, &new_data) {
                    let _ = window.emit("scan_error", e);
                    return;
                }

                // 4. Gửi dữ liệu mới về cho frontend
                let _ = window.emit("scan_complete", &new_data);

                // 5. Kiểm tra và thực hiện đồng bộ TỰ ĐỘNG ngay tại đây
                let sync_enabled = new_data.sync_enabled.unwrap_or(false);
                let has_changed = old_hash != new_data.data_hash;

                if sync_enabled && has_changed && new_data.sync_path.is_some() {
                    let _ = window.emit("auto_sync_started", "Phát hiện thay đổi, bắt đầu đồng bộ...");
                    perform_auto_export(&path, &new_data);
                    let _ = window.emit("auto_sync_complete", "Đồng bộ hoàn tất.");
                }
            }
            Err(e) => {
                let _ = window.emit("scan_error", e);
            }
        }
    });
}

#[command]
// Bỏ _app_handle không cần thiết
pub fn update_groups_in_project_data(path: String, groups: Vec<models::Group>) -> Result<(), String> {
    let mut project_data = file_cache::load_project_data(&path)?;
    project_data.groups = groups;
    file_cache::save_project_data(&path, &project_data)
}

#[command]
// Bỏ _app_handle không cần thiết
pub fn calculate_group_stats_from_cache(root_path_str: String, paths: Vec<String>) -> Result<models::GroupStats, String> {
    let project_data = file_cache::load_project_data(&root_path_str)?;
    let root_path = Path::new(&root_path_str);
    Ok(project_scanner::recalculate_stats_for_paths(&paths, &project_data.file_metadata_cache, root_path))
}

#[command]
// Bỏ app_handle không cần thiết
pub fn start_group_update(window: Window, group_id: String, root_path_str: String, paths: Vec<String>) {
    std::thread::spawn(move || {
        // Gọi hàm không cần app_handle
        let result = calculate_group_stats_from_cache(root_path_str.clone(), paths.clone());
        match result {
            Ok(new_stats) => {
                if let Ok(mut project_data) = file_cache::load_project_data(&root_path_str) {
                    if let Some(group) = project_data.groups.iter_mut().find(|g| g.id == group_id) {
                        group.paths = paths.clone();
                        group.stats = new_stats;

                        // --- LOGIC MỚI: KIỂM TRA VÀ KÍCH HOẠT ĐỒNG BỘ SAU KHI CẬP NHẬT NHÓM ---
                        let sync_enabled = project_data.sync_enabled.unwrap_or(false);
                        if sync_enabled && project_data.sync_path.is_some() {
                            let _ = window.emit("auto_sync_started", "Phát hiện thay đổi nhóm, bắt đầu đồng bộ...");
                            perform_auto_export(&root_path_str, &project_data);
                            let _ = window.emit("auto_sync_complete", "Đồng bộ hoàn tất.");
                        }
                        // --- KẾT THÚC LOGIC MỚI ---

                    }
                    let _ = file_cache::save_project_data(&root_path_str, &project_data);
                }
                let _ = window.emit("group_update_complete", serde_json::json!({
                    "groupId": group_id,
                    "paths": paths,
                    "stats": new_stats
                }));
            }
            Err(e) => {
                let _ = window.emit("group_update_error", e);
            }
        }
    });
}

#[command]
// Chữ ký đã đúng, giữ nguyên
pub fn start_group_export(window: Window, group_id: String, root_path_str: String, use_full_tree: bool) { // <-- THÊM use_full_tree
    println!("[RUST] EXPORT: Nhận yêu cầu cho nhóm ID: {}, use_full_tree: {}", group_id, use_full_tree);
    std::thread::spawn(move || {
        let result: Result<String, String> = (|| {
            let project_data = file_cache::load_project_data(&root_path_str)?;
            let root_path = Path::new(&root_path_str);
            let group = project_data.groups.iter()
                .find(|g| g.id == group_id)
                .ok_or_else(|| format!("Không tìm thấy nhóm với ID: {}", group_id))?;
            
            println!("[RUST] EXPORT: Đã tìm thấy nhóm '{}'. Paths được lưu: {:?}", group.name, group.paths);
            let expanded_files = context_generator::expand_group_paths_to_files(&group.paths, &project_data.file_metadata_cache, root_path);
            
            println!("[RUST] EXPORT: Sau khi mở rộng, có {} files: {:?}", expanded_files.len(), expanded_files);
            if expanded_files.is_empty() {
                return Err("Nhóm này không chứa file nào để xuất.".to_string());
            }
            context_generator::generate_context_from_files(
                &root_path_str, 
                &expanded_files,
                use_full_tree, // <-- Truyền tham số
                &project_data.file_tree, // <-- Truyền cả cây thư mục đầy đủ
            )
        })();
        match result {
            Ok(context) => {
                println!("[RUST] EXPORT: Thành công! Đang gửi sự kiện group_export_complete.");
                let _ = window.emit("group_export_complete", serde_json::json!({ "groupId": group_id, "context": context }));
            }
            Err(e) => {
                println!("[RUST] EXPORT: Lỗi! Đang gửi sự kiện group_export_error: {}", e);
                let _ = window.emit("group_export_error", e);
            }
        }
    });
}

#[command]
// Bỏ app_handle không cần thiết
pub fn start_project_export(window: Window, path: String) {
    std::thread::spawn(move || {
        let result: Result<String, String> = (|| {
            let project_data = file_cache::load_project_data(&path)?;
            let all_files: Vec<String> = project_data.file_metadata_cache.keys().cloned().collect();
            if all_files.is_empty() {
                return Err("Dự án không có file nào để xuất.".to_string());
            }
            // --- SỬA LỖI Ở ĐÂY ---
            // Cung cấp 2 tham số còn thiếu
            context_generator::generate_context_from_files(
                &path, 
                &all_files,
                true, // Luôn dùng cây thư mục đầy đủ khi xuất toàn bộ dự án
                &project_data.file_tree // Cung cấp cây thư mục đầy đủ
            )
            // --- KẾT THÚC SỬA LỖI ---
        })();
        match result {
            Ok(context) => {
                let _ = window.emit("project_export_complete", context);
            }
            Err(e) => {
                let _ = window.emit("project_export_error", e);
            }
        }
    });
}

// --- COMMAND MỚI: Cập nhật cài đặt đồng bộ ---
#[command]
pub fn update_sync_settings(path: String, enabled: bool, sync_path: Option<String>) -> Result<(), String> {
    let mut project_data = file_cache::load_project_data(&path)?;
    project_data.sync_enabled = Some(enabled);
    project_data.sync_path = sync_path;
    file_cache::save_project_data(&path, &project_data)
}

// --- HÀM HELPER: Lưu context, được sử dụng bởi auto_export ---
fn save_context_to_path_internal(path: String, content: String) -> Result<(), String> {
    let file_path = Path::new(&path);
    if let Some(parent) = file_path.parent() {
        fs::create_dir_all(parent)
            .map_err(|e| format!("Không thể tạo thư mục cha: {}", e))?;
    }
    fs::write(file_path, content)
        .map_err(|e| format!("Không thể ghi vào file: {}", e))
}

// --- HÀM HELPER MỚI: Logic xuất tự động ---
fn perform_auto_export(project_path: &str, data: &models::CachedProjectData) {
    let sync_path_base = PathBuf::from(data.sync_path.as_ref().unwrap());
    
    // 1. Xuất toàn bộ dự án
    let all_files: Vec<String> = data.file_metadata_cache.keys().cloned().collect();
    if let Ok(proj_context) = context_generator::generate_context_from_files(project_path, &all_files, true, &data.file_tree) {
        let file_name = sync_path_base.join("_PROJECT_CONTEXT.txt");
        let _ = save_context_to_path_internal(file_name.to_string_lossy().to_string(), proj_context);
    }

    // 2. Xuất từng nhóm
    for group in &data.groups {
        let expanded_files = context_generator::expand_group_paths_to_files(&group.paths, &data.file_metadata_cache, Path::new(project_path));
        if !expanded_files.is_empty() {
            if let Ok(group_context) = context_generator::generate_context_from_files(project_path, &expanded_files, true, &data.file_tree) {
                let safe_name = group.name.replace(|c: char| !c.is_alphanumeric(), "_");
                let file_name = sync_path_base.join(format!("{}_context.txt", safe_name));
                let _ = save_context_to_path_internal(file_name.to_string_lossy().to_string(), group_context);
            }
        }
    }
}

================================================
FILE: src-tauri/src/context_generator.rs
================================================
// src-tauri/src/context_generator.rs
use crate::models::{FsEntry, FileNode}; // <-- Thêm FileNode
use std::collections::{BTreeMap, HashSet};
use std::fs;
use std::path::Path;
use std::fmt::Write as FmtWrite;

fn format_tree(tree: &BTreeMap<String, FsEntry>, prefix: &str, output: &mut String) {
    let mut entries = tree.iter().peekable();
    while let Some((name, entry)) = entries.next() {
        let is_last = entries.peek().is_none();
        let connector = if is_last { "└── " } else { "├── " };
        match entry {
            FsEntry::File => { let _ = writeln!(output, "{}{}{}", prefix, connector, name); }
            FsEntry::Directory(children) => {
                let _ = writeln!(output, "{}{}{}/", prefix, connector, name);
                let new_prefix = format!("{}{}", prefix, if is_last { "    " } else { "│   " });
                format_tree(children, &new_prefix, output);
            }
        }
    }
}

// --- HÀM HELPER MỚI: Chuyển đổi từ FileNode (của cache) sang FsEntry (của builder) ---
fn convert_file_node_to_fs_entry(node: &FileNode) -> FsEntry {
    if let Some(children) = &node.children {
        let mut child_map = BTreeMap::new();
        for child in children {
            child_map.insert(child.name.clone(), convert_file_node_to_fs_entry(child));
        }
        FsEntry::Directory(child_map)
    } else {
        FsEntry::File
    }
}


// === BẮT ĐẦU PHẦN SỬA LỖI DỨT ĐIỂM ===
pub fn expand_group_paths_to_files(
    group_paths: &[String],
    metadata_cache: &BTreeMap<String, crate::models::FileMetadata>,
    _root_path: &Path, // Không cần truy cập đĩa nữa
) -> Vec<String> {
    let mut all_files_in_group: HashSet<String> = HashSet::new();

    // Lấy danh sách tất cả các file đã được quét để duyệt hiệu quả hơn
    let all_cached_files: Vec<&String> = metadata_cache.keys().collect();

    for path_str in group_paths {
        // Xử lý trường hợp đường dẫn đã lưu là MỘT FILE cụ thể
        // Ví dụ: path_str = "src/App.tsx"
        if metadata_cache.contains_key(path_str) {
            all_files_in_group.insert(path_str.clone());
        }

        // Xử lý trường hợp đường dẫn đã lưu là MỘT THƯ MỤC
        // Ví dụ: path_str = "src" -> tìm các file bắt đầu bằng "src/"
        let dir_prefix = format!("{}/", path_str);
        for &cached_file in &all_cached_files {
            // Nếu path_str là thư mục gốc ("") thì dir_prefix sẽ là "/"
            // và cached_file cũng sẽ bắt đầu bằng "/", điều này không đúng.
            // Do đó, cần xử lý trường hợp thư mục gốc một cách đặc biệt.
            if path_str.is_empty() {
                 all_files_in_group.insert(cached_file.clone());
            } else if cached_file.starts_with(&dir_prefix) {
                all_files_in_group.insert(cached_file.clone());
            }
        }
    }

    all_files_in_group.into_iter().collect()
}
// === KẾT THÚC PHẦN SỬA LỖI DỨT ĐIỂM ===


// --- CẬP NHẬT CHỮ KÝ VÀ LOGIC CỦA HÀM NÀY ---
pub fn generate_context_from_files(
    root_path_str: &str, 
    file_paths: &[String],
    use_full_tree: bool,
    full_project_tree: &Option<FileNode>,
) -> Result<String, String> {
    let root_path = Path::new(root_path_str);
    let mut tree_builder_root = BTreeMap::new();

    // --- LOGIC IF/ELSE MỚI ĐỂ XÂY DỰNG CÂY THƯ MỤC ---
    if use_full_tree {
        if let Some(tree_node) = full_project_tree {
             if let FsEntry::Directory(root_children) = convert_file_node_to_fs_entry(tree_node) {
                tree_builder_root = root_children;
            }
        } else {
            return Err("Không tìm thấy cây thư mục đầy đủ trong cache.".to_string());
        }
    } else {
        // Giữ lại logic cũ để xây dựng cây thư mục tối giản
        for rel_path_str in file_paths {
            let rel_path = Path::new(rel_path_str);
            let mut current_level = &mut tree_builder_root;
            if let Some(components) = rel_path.parent() {
                for component in components.components() {
                    let component_str = component.as_os_str().to_string_lossy().into_owned();
                    current_level = match current_level.entry(component_str).or_insert(FsEntry::Directory(BTreeMap::new())) {
                        FsEntry::Directory(children) => children,
                        _ => unreachable!(),
                    };
                }
            }
            if let Some(file_name) = rel_path.file_name() {
                let file_name_str = file_name.to_string_lossy().into_owned();
                current_level.insert(file_name_str, FsEntry::File);
            }
        }
    }

    let mut directory_structure = String::new();
    format_tree(&tree_builder_root, "", &mut directory_structure);
    
    // Phần xử lý nội dung file giữ nguyên, không thay đổi
    let mut file_contents_string = String::new();
    let mut sorted_files = file_paths.to_vec();
    sorted_files.sort();
    for file_rel_path in sorted_files {
        let file_path = root_path.join(&file_rel_path);
        if let Ok(content) = fs::read_to_string(&file_path) {
            let header = format!("================================================\nFILE: {}\n================================================\n", file_rel_path.replace("\\", "/"));
            file_contents_string.push_str(&header);
            file_contents_string.push_str(&content);
            file_contents_string.push_str("\n\n");
        }
    }
    let final_context = format!("Directory structure:\n{}\n\n{}", directory_structure, file_contents_string);
    Ok(final_context)
}

================================================
FILE: src-tauri/src/file_cache.rs
================================================
// src-tauri/src/file_cache.rs
use crate::models::CachedProjectData;
use std::fs::{self, File};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};

pub fn get_project_config_path(project_path_str: &str) -> Result<PathBuf, String> {
    let project_path = Path::new(project_path_str);
    if !project_path.is_dir() {
        return Err(format!("'{}' không phải là một thư mục hợp lệ.", project_path_str));
    }
    let config_dir = project_path.join(".mastercontext");
    fs::create_dir_all(&config_dir)
        .map_err(|e| format!("Không thể tạo thư mục cấu hình '.mastercontext': {}", e))?;
    Ok(config_dir.join("data.json"))
}

pub fn load_project_data(path: &str) -> Result<CachedProjectData, String> {
    let config_path = get_project_config_path(path)?;
    if !config_path.exists() {
        return Ok(CachedProjectData::default());
    }
    let mut file = File::open(config_path).map_err(|e| format!("Không thể mở file dữ liệu dự án: {}", e))?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).map_err(|e| format!("Không thể đọc file dữ liệu dự án: {}", e))?;
    if contents.is_empty() {
        return Ok(CachedProjectData::default());
    }
    serde_json::from_str(&contents).map_err(|e| format!("Lỗi phân tích cú pháp JSON: {}", e))
}

pub fn save_project_data(path: &str, data: &CachedProjectData) -> Result<(), String> {
    let config_path = get_project_config_path(path)?;
    let json_string = serde_json::to_string_pretty(data)
        .map_err(|e| format!("Không thể serialize dữ liệu dự án: {}", e))?;
    let mut file = File::create(config_path)
        .map_err(|e| format!("Không thể tạo/ghi file dữ liệu dự án: {}", e))?;
    file.write_all(json_string.as_bytes())
        .map_err(|e| format!("Lỗi khi ghi file dữ liệu dự án: {}", e))?;
    Ok(())
}

================================================
FILE: src-tauri/src/lib.rs
================================================
// src-tauri/src/lib.rs

// Khai báo các module mới
mod models;
mod file_cache;
mod context_generator;
mod project_scanner;
mod commands;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_opener::init())
        .plugin(tauri_plugin_fs::init())
        .invoke_handler(tauri::generate_handler![
            commands::open_project,
            commands::update_groups_in_project_data,
            commands::start_group_update,
            commands::start_group_export,
            commands::start_project_export,
            commands::calculate_group_stats_from_cache,
            commands::update_sync_settings
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

================================================
FILE: src-tauri/src/main.rs
================================================
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    master_context_lib::run()
}


================================================
FILE: src-tauri/src/models.rs
================================================
// src-tauri/src/models.rs
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

// --- THÊM CÁC STRUCT MỚI Ở ĐẦU FILE ---
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TsConfig {
    pub compiler_options: Option<CompilerOptions>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct CompilerOptions {
    pub base_url: Option<String>,
    pub paths: Option<BTreeMap<String, Vec<String>>>,
}
// --- KẾT THÚC PHẦN THÊM MỚI ---

#[derive(Serialize, Deserialize, Debug, Default, Clone, Copy)]
pub struct GroupStats {
    pub total_files: u64,
    pub total_dirs: u64,
    pub total_size: u64,
    pub token_count: usize,
}

#[derive(Serialize, Deserialize, Debug, Default, Clone)]
pub struct ProjectStats {
    pub total_files: u64,
    pub total_dirs: u64,
    pub total_size: u64,
    pub total_tokens: usize,
}

#[derive(Serialize, Deserialize, Debug, Default, Clone)]
pub struct FileNode {
    pub name: String,
    pub path: String,
    pub children: Option<Vec<FileNode>>,
}

#[derive(Serialize, Deserialize, Debug, Default, Clone)]
pub struct Group {
    pub id: String,
    pub name: String,
    pub description: String,
    pub paths: Vec<String>,
    pub stats: GroupStats,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FileMetadata {
    pub size: u64,
    pub mtime: u64,
    pub token_count: usize,
    pub links: Vec<String>,
}

#[derive(Serialize, Deserialize, Debug, Default, Clone)]
pub struct CachedProjectData {
    pub stats: ProjectStats,
    pub file_tree: Option<FileNode>,
    pub groups: Vec<Group>,
    pub file_metadata_cache: BTreeMap<String, FileMetadata>,
    pub sync_enabled: Option<bool>,
    pub sync_path: Option<String>,
    pub data_hash: Option<String>,
}

#[derive(Debug, Clone)]
pub enum FsEntry {
    File,
    Directory(BTreeMap<String, FsEntry>),
}

================================================
FILE: src-tauri/src/project_scanner.rs
================================================
// src-tauri/src/project_scanner.rs
use crate::models::{CachedProjectData, FileMetadata, FileNode, GroupStats, ProjectStats, TsConfig};
use crate::file_cache;
use std::collections::{BTreeMap, HashSet};
use std::fs;
use std::path::{Path, PathBuf};
use std::time::UNIX_EPOCH;
// use tauri::{Emitter, Window}; // Không còn cần vì hàm không emit nữa
use ignore::{WalkBuilder, overrides::OverrideBuilder};
use tiktoken_rs::cl100k_base;
use regex::Regex;
use lazy_static::lazy_static;
use path_clean::PathClean;
use sha2::{Sha256, Digest};

pub fn recalculate_stats_for_paths(
    paths: &[String],
    metadata_cache: &BTreeMap<String, FileMetadata>,
    _root_path: &Path, // _root_path không còn cần thiết
) -> GroupStats {
    let mut stats = GroupStats::default();
    let mut all_files_in_group: HashSet<String> = HashSet::new();
    let mut all_dirs_in_group: HashSet<String> = HashSet::new();

    let all_cached_files: Vec<&String> = metadata_cache.keys().collect();

    // Mở rộng các đường dẫn tối thiểu thành một danh sách file đầy đủ
    for path_str in paths {
        // Xử lý trường hợp đường dẫn là MỘT FILE
        if metadata_cache.contains_key(path_str) {
            all_files_in_group.insert(path_str.clone());
        }

        // Xử lý trường hợp đường dẫn là MỘT THƯ MỤC
        let dir_prefix = format!("{}/", path_str);
        if !path_str.is_empty() {
             all_dirs_in_group.insert(path_str.clone());
        }

        for &cached_file in &all_cached_files {
            if path_str.is_empty() {
                all_files_in_group.insert(cached_file.clone());
            } else if cached_file.starts_with(&dir_prefix) {
                all_files_in_group.insert(cached_file.clone());
            }
        }
    }

    // Dùng cache để suy ra các thư mục cha từ đường dẫn file
    let mut subdirs_from_files = HashSet::new();
    for file_path in &all_files_in_group {
        let mut current = Path::new(file_path);
        while let Some(parent) = current.parent() {
            if parent.as_os_str().is_empty() { break; }
            let parent_str = parent.to_string_lossy().replace("\\", "/");
            subdirs_from_files.insert(parent_str);
            current = parent;
        }
    }
    all_dirs_in_group.extend(subdirs_from_files);

    // Tính toán stats từ danh sách file đã mở rộng và cache
    for file_path_str in &all_files_in_group {
        if let Some(meta) = metadata_cache.get(file_path_str) {
            stats.total_size += meta.size;
            stats.token_count += meta.token_count;
        }
    }

    stats.total_files = all_files_in_group.len() as u64;
    stats.total_dirs = all_dirs_in_group.len() as u64;

    stats
}

// --- THÊM KHỐI MÃ NÀY ---
// Biên dịch các regex một lần duy nhất để tăng hiệu suất
lazy_static! {
    // --- THAY THẾ BẰNG REGEX ĐƠN GIẢN HƠN VÀ MẠNH MẼ HƠN ---
    static ref IMPORT_EXPORT_REGEX: Regex = Regex::new(
        r#"(?:from|import|require)\s*\(?\s*['"](?P<path>[./@][^'"]+)['"]\s*\)?"#
    ).unwrap();
}

// --- THAY ĐỔI HÀM NÀY ĐỂ NHẬN VÀO ALIAS MAP ---
fn resolve_link(
    current_file_path: &Path,
    link_path_str: &str,
    all_project_files: &HashSet<String>,
    aliases: &BTreeMap<String, String>, // <-- THAM SỐ MỚI
) -> Option<String> {
    let mut cleaned_path: Option<PathBuf> = None;

    // --- BẮT ĐẦU LOGIC PHÂN GIẢI MỚI, LINH HOẠT HƠN ---
    // Trường hợp 1: Kiểm tra xem đường dẫn có khớp với alias nào không
    for (alias, base_path) in aliases {
        if let Some(stripped) = link_path_str.strip_prefix(alias) {
            let full_path = Path::new(base_path).join(stripped);
            cleaned_path = Some(full_path.clean());
            break; // Tìm thấy alias đầu tiên khớp, thoát khỏi vòng lặp
        }
    }

    if cleaned_path.is_none() {
        if link_path_str.starts_with('.') {
            // Trường hợp 2: Tương đối (nếu không có alias nào khớp)
            let current_dir = current_file_path.parent().unwrap_or_else(|| Path::new(""));
            cleaned_path = Some(current_dir.join(link_path_str).clean());
        } else {
            // Trường hợp 3: Package npm hoặc không hợp lệ, bỏ qua
            return None;
        }
    }
    // --- KẾT THÚC LOGIC PHÂN GIẢI MỚI ---

    let cleaned_path_str = cleaned_path.unwrap().to_string_lossy().replace("\\", "/");

    // Thử tìm file với các extension phổ biến
    let extensions = ["", ".ts", ".tsx", ".js", ".jsx", ".json"];
    for ext in extensions.iter() {
        // Thử trường hợp 1: Đường dẫn chính xác (có thể có hoặc không có extension)
        // ví dụ: ./utils.ts -> utils.ts
        let potential_path = format!("{}{}", cleaned_path_str, ext);
        if all_project_files.contains(&potential_path) {
            return Some(potential_path);
        }

        // Thử trường hợp 2: Đường dẫn là một thư mục, tìm file index bên trong
        // ví dụ: ./components -> ./components/index.ts
        let potential_index_path = format!("{}/index{}", cleaned_path_str, ext);
        if all_project_files.contains(&potential_index_path) {
            return Some(potential_index_path);
        }
    }

    None
}

pub fn perform_smart_scan_and_rebuild(path: &str) -> Result<CachedProjectData, String> {
    let root_path = Path::new(path);
    let bpe = cl100k_base().map_err(|e| e.to_string())?;

    let old_data = file_cache::load_project_data(path).unwrap_or_default();
    let old_metadata_cache = old_data.file_metadata_cache;

    let mut new_project_stats = ProjectStats::default();
    let mut new_metadata_cache = BTreeMap::new();
    let mut path_map = BTreeMap::new(); // Dùng để xây dựng cây thư mục

    // --- BƯỚC MỚI: ĐỌC VÀ PHÂN TÍCH ALIAS ---
    let mut aliases = BTreeMap::new();
    let tsconfig_path = root_path.join("tsconfig.json");
    let jsconfig_path = root_path.join("jsconfig.json");

    let config_path = if tsconfig_path.exists() {
        Some(tsconfig_path)
    } else if jsconfig_path.exists() {
        Some(jsconfig_path)
    } else {
        None
    };

    if let Some(path) = config_path {
        if let Ok(content) = fs::read_to_string(path) {
            if let Ok(tsconfig) = serde_json::from_str::<TsConfig>(&content) {
                if let Some(options) = tsconfig.compiler_options {
                    let base_url = options.base_url.unwrap_or_else(|| ".".to_string());
                    if let Some(paths) = options.paths {
                        for (alias, replacements) in paths {
                            // Chỉ lấy replacement đầu tiên và đơn giản hóa nó
                            if let Some(first_replacement) = replacements.get(0) {
                                // Bỏ "/*" ở cuối alias và replacement
                                let clean_alias = alias.strip_suffix("/*").unwrap_or(&alias);
                                let clean_replacement = first_replacement.strip_suffix("/*").unwrap_or(first_replacement);
                                
                                // Tạo đường dẫn đầy đủ từ baseUrl
                                let full_base_path = Path::new(&base_url).join(clean_replacement).clean();
                                aliases.insert(
                                    clean_alias.to_string(), 
                                    full_base_path.to_string_lossy().to_string()
                                );
                            }
                        }
                    }
                }
            }
        }
    }
    // Hard-code alias mặc định nếu không tìm thấy trong tsconfig
    // Điều này giúp tương thích ngược với các dự án không có cấu hình rõ ràng
    aliases.entry("@/".to_string()).or_insert_with(|| "src/".to_string());
    println!("[INFO] Aliases đã phát hiện: {:?}", aliases);
    // --- KẾT THÚC PHẦN PHÂN TÍCH ALIAS ---

    let override_builder = {
        let mut builder = OverrideBuilder::new(root_path);
        builder.add("!package-lock.json").map_err(|e| e.to_string())?;
        builder.add("!Cargo.lock").map_err(|e| e.to_string())?;
        builder.add("!yarn.lock").map_err(|e| e.to_string())?;
        builder.add("!pnpm-lock.yaml").map_err(|e| e.to_string())?;
        builder.build().map_err(|e| e.to_string())?
    };

    // --- BƯỚC 1: Quét một lần duy nhất và thu thập thông tin thô ---
    struct RawFileInfo {
        relative_path: PathBuf,
        metadata: std::fs::Metadata,
        content: Option<String>,
    }
    let mut raw_files: Vec<RawFileInfo> = Vec::new();
    let mut all_valid_files = HashSet::new();

    for entry in WalkBuilder::new(root_path).overrides(override_builder.clone()).build().filter_map(Result::ok) {
        let entry_path = entry.path();
        if let (Ok(relative_path), Ok(metadata)) = (entry_path.strip_prefix(root_path), entry.metadata()) {
            if relative_path.as_os_str().is_empty() { continue; }
            
            // Bỏ qua việc gửi progress trong lần refactor này để đơn giản hóa
            path_map.insert(entry_path.to_path_buf(), metadata.is_dir());

            if metadata.is_dir() {
                new_project_stats.total_dirs += 1;
            } else if metadata.is_file() {
                new_project_stats.total_files += 1;
                new_project_stats.total_size += metadata.len();
                
                let content = fs::read_to_string(entry_path).ok();
                raw_files.push(RawFileInfo {
                    relative_path: relative_path.to_path_buf(),
                    metadata,
                    content,
                });
                all_valid_files.insert(relative_path.to_string_lossy().replace("\\", "/"));
            }
        }
    }

    // --- BƯỚC 2: Xử lý thông tin thô để xây dựng metadata cache ---
    for file_info in raw_files {
        let relative_path_str = file_info.relative_path.to_string_lossy().replace("\\", "/");
        let current_mtime = file_info.metadata.modified()
            .map(|t| t.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs())
            .unwrap_or(0);
        
        let mut token_count = 0;
        let mut links = Vec::new();

        if let Some(cached_meta) = old_metadata_cache.get(&relative_path_str) {
            if cached_meta.size == file_info.metadata.len() && cached_meta.mtime == current_mtime {
                token_count = cached_meta.token_count;
                links = cached_meta.links.clone();
            }
        }

        if token_count == 0 { // Nếu file mới/thay đổi, xử lý lại
            if let Some(content) = &file_info.content { // <-- Thêm & để borrow
                token_count = bpe.encode_with_special_tokens(content).len();
                
                let mut found_links = HashSet::new();
                
                // --- BẮT ĐẦU VÙNG DEBUG SÂU ---
                println!("\n[DEBUG] Đang phân tích file: {}", relative_path_str);
                
                for cap in IMPORT_EXPORT_REGEX.captures_iter(content) {
                    // Lấy group có tên "path" hoặc "path2"
                    let link_path_opt = cap.name("path");
                    
                    if let Some(link_path_match) = link_path_opt {
                        let link_path = link_path_match.as_str();
                        println!("[DEBUG]   => Regex khớp: '{}'", link_path);
                        
                        if let Some(resolved) = resolve_link(&file_info.relative_path, link_path, &all_valid_files, &aliases) {
                            println!("[DEBUG]     => Phân giải thành công: '{}'", resolved);
                            found_links.insert(resolved);
                        } else {
                            println!("[DEBUG]     => Phân giải thất bại.");
                        }
                    } else {
                        // In ra toàn bộ capture để xem có gì sai không
                        println!("[DEBUG]   => Regex khớp nhưng không tìm thấy group 'path'. Full capture: {:?}", &cap);
                    }
                }
                // --- KẾT THÚC VÙNG DEBUG SÂU ---
                
                links = found_links.into_iter().collect();
            }
        }

        new_project_stats.total_tokens += token_count;
        new_metadata_cache.insert(relative_path_str, FileMetadata {
            size: file_info.metadata.len(),
            mtime: current_mtime,
            token_count,
            links,
        });
    }

    // --- BƯỚC 3: Xây dựng cây thư mục và cập nhật nhóm (giữ nguyên) ---
    fn build_tree_from_map(parent: &Path, path_map: &BTreeMap<PathBuf, bool>, root_path: &Path) -> Vec<FileNode> {
        let mut children = Vec::new();
        for (path, is_dir) in path_map.range(parent.join("")..) {
            if path.parent() == Some(parent) {
                let name = path.file_name().unwrap_or_default().to_string_lossy().to_string();
                let relative_path_str = path.strip_prefix(root_path).unwrap().to_string_lossy().replace("\\", "/");
                children.push(FileNode {
                    name,
                    path: relative_path_str,
                    children: if *is_dir { Some(build_tree_from_map(path, path_map, root_path)) } else { None },
                });
            }
        }
        children.sort_by(|a, b| {
            let a_is_dir = a.children.is_some(); let b_is_dir = b.children.is_some();
            if a_is_dir != b_is_dir { b_is_dir.cmp(&a_is_dir) } else { a.name.cmp(&b.name) }
        });
        children
    }
    let root_children = build_tree_from_map(root_path, &path_map, root_path);
    let file_tree = FileNode {
        name: root_path.file_name().unwrap_or_default().to_string_lossy().to_string(),
        path: "".to_string(),
        children: Some(root_children),
    };

    let mut updated_groups = old_data.groups;
    for group in &mut updated_groups {
        group.paths.retain(|path| new_metadata_cache.contains_key(path) || path_map.values().any(|is_dir| *is_dir));
        group.stats = recalculate_stats_for_paths(&group.paths, &new_metadata_cache, root_path);
    }

    // --- BƯỚC 4: Tính toán hash để theo dõi thay đổi ---
    let metadata_json = serde_json::to_string(&new_metadata_cache).unwrap_or_default();
    let mut hasher = Sha256::new();
    hasher.update(metadata_json.as_bytes());
    let hash_result = hasher.finalize();
    let data_hash = format!("{:x}", hash_result);

    let final_data = CachedProjectData {
        stats: new_project_stats,
        file_tree: Some(file_tree),
        groups: updated_groups,
        file_metadata_cache: new_metadata_cache,
        sync_enabled: old_data.sync_enabled, // Giữ lại cài đặt cũ
        sync_path: old_data.sync_path,       // Giữ lại cài đặt cũ
        data_hash: Some(data_hash),
    };

    // --- THAY ĐỔI: Trả về dữ liệu thay vì lưu và emit ---
    Ok(final_data)
}

================================================
FILE: src-tauri/tauri.conf.json
================================================
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "master-context",
  "version": "0.1.0",
  "identifier": "com.tomisakae.master-context",
  "build": {
    "beforeDevCommand": "npm run dev",
    "devUrl": "http://localhost:1420",
    "beforeBuildCommand": "npm run build",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "title": "Master Context",
        "width": 1280,
        "height": 720
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ]
  }
}


